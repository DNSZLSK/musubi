<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MUSUBI</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAuElEQVR4nGNgGAVDHfDL8f+nRD8jrSz7+OgjUWYT7YCUOykk+3SOyhyC5hNUQI7FpDiEidaWEzIHp8soTVzYALZ0gTcE6AGwhgC1gh4bQE8PGCFAS8uxmT/4ooAWiQ8dICfGAQ8BFnSB0H2hNLd0jsocOBslBGidALHZg+IAYspuagBke0YT4eBKhAMBMBxA64SIbv5odYw3uKlZMOGKWrwhQK30gM+cwd8qRga06BdQDOhRdA9vAABjbkwqWmLx7QAAAABJRU5ErkJggg==">
    
    <!-- Open Graph / Share -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="MUSUBI">
    <meta property="og:description" content="A retro logic puzzle game. Fill the circles to match the numbers!">
    <meta property="og:image" content="https://raw.githubusercontent.com/DNSZLSK/musubi/master/Images/musubi%20logo%204.png">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="MUSUBI">
    <meta name="twitter:description" content="A retro logic puzzle game. Fill the circles to match the numbers!">
    
    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #stars-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #game-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.3s ease-out;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Menu screen */
        #menu-screen {
            justify-content: center;
            gap: 5px;
        }

        #logo-img {
            width: 650px;
            max-width: 95%;
            height: auto;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 10px rgba(74, 170, 74, 0.4));
        }
        
        /* Logo color per theme */
        body #logo-img { filter: hue-rotate(0deg) drop-shadow(0 0 10px rgba(74, 170, 74, 0.4)); }
        body.theme-cyan #logo-img { filter: hue-rotate(160deg) drop-shadow(0 0 10px rgba(74, 170, 170, 0.4)); }
        body.theme-amber #logo-img { filter: hue-rotate(-80deg) saturate(1.2) drop-shadow(0 0 10px rgba(170, 136, 74, 0.4)); }
        body.theme-white #logo-img { filter: saturate(0) brightness(1.3) drop-shadow(0 0 10px rgba(150, 150, 150, 0.4)); }
        body.theme-pink #logo-img { filter: hue-rotate(280deg) drop-shadow(0 0 10px rgba(170, 74, 170, 0.4)); }

        .menu-item {
            cursor: pointer;
            margin: 8px 0;
            transition: transform 0.1s, filter 0.2s;
            filter: drop-shadow(0 0 2px var(--color));
        }

        .menu-item:hover {
            filter: drop-shadow(0 0 4px var(--color)) drop-shadow(0 0 10px var(--color));
        }

        .menu-item:active {
            transform: scale(0.95);
        }

        /* Game screen */
        #game-screen {
            padding: 20px;
            justify-content: flex-start;
            padding-top: 80px;
        }

        #top-bar {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #top-icons {
            display: flex;
            gap: 15px;
        }

        #top-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Equalizer */
        #equalizer {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 25px;
        }

        #equalizer.paused .eq-bar {
            animation-play-state: paused;
            height: 5px !important;
        }

        .eq-bar {
            width: 4px;
            background: var(--color);
            animation: equalize 0.8s ease-in-out infinite;
        }

        .eq-bar:nth-child(1) { animation-delay: 0s; }
        .eq-bar:nth-child(2) { animation-delay: 0.2s; }
        .eq-bar:nth-child(3) { animation-delay: 0.4s; }
        .eq-bar:nth-child(4) { animation-delay: 0.1s; }

        @keyframes equalize {
            0%, 100% { height: 5px; }
            50% { height: 20px; }
        }

        .top-icon {
            cursor: pointer;
            transition: filter 0.2s;
            filter: drop-shadow(0 0 2px var(--color));
        }
        
        .top-icon:hover {
            filter: drop-shadow(0 0 4px var(--color)) drop-shadow(0 0 10px var(--color));
        }

        #puzzle-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #puzzle-canvas {
            max-width: 100%;
            filter: drop-shadow(0 0 3px var(--color));
        }

        #mode-canvas {
            margin-top: 25px;
            filter: drop-shadow(0 0 5px var(--color)) drop-shadow(0 0 12px var(--color));
        }

        /* Difficulty screen */
        #difficulty-screen {
            justify-content: space-between;
            padding: 60px 20px 40px;
        }

        /* How to play */
        #howto-screen {
            justify-content: space-between;
            padding: 60px 20px 40px;
        }

        /* Nickname */
        #nickname-screen {
            justify-content: space-between;
            padding: 60px 20px 40px;
        }
        
        #nickname-screen .content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #nickname-input {
            background: transparent;
            border: none;
            outline: none;
            font-family: monospace;
            font-size: 20px;
            color: #4a4;
            text-align: center;
            letter-spacing: 3px;
            width: 200px;
            margin: 20px 0;
            padding: 10px;
            border-bottom: 2px solid #4a4;
        }

        /* Leaderboard */
        #leaderboard-screen {
            justify-content: space-between;
            padding: 60px 20px 40px;
        }
        
        .content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Theme colors - boosted brightness */
        body { --color: #5c5; --color-bright: #7f7; }
        body.theme-cyan { --color: #5cc; --color-bright: #7ee; }
        body.theme-amber { --color: #ca6; --color-bright: #ec8; }
        body.theme-white { --color: #bbb; --color-bright: #ddd; }
        body.theme-pink { --color: #c5c; --color-bright: #e7e; }

        /* Preloader */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        #preloader-text {
            color: #5c5;
            font-family: monospace;
            font-size: 24px;
            margin-bottom: 20px;
            letter-spacing: 4px;
        }
        
        #preloader-bar-container {
            width: 200px;
            height: 4px;
            background: #222;
            border: 1px solid #5c5;
        }
        
        #preloader-bar {
            width: 0%;
            height: 100%;
            background: #5c5;
            transition: width 0.2s;
        }
    </style>
</head>
<body>
    <!-- PRELOADER -->
    <div id="preloader">
        <div id="preloader-text">LOADING...</div>
        <div id="preloader-bar-container">
            <div id="preloader-bar"></div>
        </div>
    </div>

    <canvas id="stars-canvas"></canvas>

    <div id="game-container" style="display: none;">
        <!-- MENU -->
        <div id="menu-screen" class="screen active">
            <img id="logo-img" src="https://raw.githubusercontent.com/DNSZLSK/musubi/master/Images/musubi%20logo%204.png" alt="MUSUBI">
            <canvas class="menu-item" id="menu-newgame" width="220" height="45"></canvas>
            <canvas class="menu-item" id="menu-leaderboard" width="280" height="45"></canvas>
            <canvas class="menu-item" id="menu-nickname" width="320" height="45"></canvas>
            <canvas class="menu-item" id="menu-howto" width="260" height="45"></canvas>
            <canvas class="menu-item" id="menu-color" width="160" height="45" style="margin-top: 25px;"></canvas>
        </div>

        <!-- DIFFICULTY -->
        <div id="difficulty-screen" class="screen">
            <canvas id="diff-title" width="300" height="50"></canvas>
            <div class="content">
                <canvas class="menu-item" id="diff-training" width="340" height="45"></canvas>
                <canvas class="menu-item" id="diff-challenge" width="360" height="45"></canvas>
                <canvas class="menu-item" id="diff-expert" width="300" height="45"></canvas>
            </div>
            <canvas class="menu-item" id="diff-back" width="120" height="40"></canvas>
        </div>

        <!-- GAME -->
        <div id="game-screen" class="screen">
            <div id="top-bar">
                <div id="top-icons">
                    <canvas class="top-icon" id="icon-stars" width="50" height="45" title="Toggle stars"></canvas>
                    <canvas class="top-icon" id="icon-music" width="50" height="45" title="Mute/Unmute"></canvas>
                    <canvas class="top-icon" id="icon-home" width="50" height="45" title="Menu"></canvas>
                </div>
                <div id="top-right">
                    <div id="equalizer" class="paused" title="Next track" style="cursor: pointer;">
                        <div class="eq-bar"></div>
                        <div class="eq-bar"></div>
                        <div class="eq-bar"></div>
                        <div class="eq-bar"></div>
                    </div>
                </div>
            </div>
            <div id="puzzle-container">
                <canvas id="puzzle-canvas" width="340" height="340"></canvas>
                <canvas id="mode-canvas" width="400" height="40"></canvas>
            </div>
        </div>

        <!-- HOW TO PLAY -->
        <div id="howto-screen" class="screen">
            <canvas id="howto-title" width="280" height="50"></canvas>
            <div class="content">
                <canvas id="howto-content" width="340" height="320"></canvas>
            </div>
            <canvas class="menu-item" id="howto-back" width="120" height="40"></canvas>
        </div>

        <!-- NICKNAME -->
        <div id="nickname-screen" class="screen">
            <canvas id="nickname-title" width="320" height="50"></canvas>
            <div class="content">
                <input type="text" id="nickname-input" maxlength="10" placeholder="PLAYER">
                <canvas class="menu-item" id="nickname-save" width="120" height="40"></canvas>
            </div>
            <canvas class="menu-item" id="nickname-back" width="120" height="40"></canvas>
        </div>

        <!-- LEADERBOARD -->
        <div id="leaderboard-screen" class="screen">
            <canvas id="leaderboard-title" width="300" height="50"></canvas>
            <div class="content">
                <canvas id="leaderboard-list" width="380" height="380"></canvas>
            </div>
            <canvas class="menu-item" id="leaderboard-back" width="120" height="40"></canvas>
        </div>
    </div>

<script>
// ===== GLOBAL VARIABLES =====
let starsEnabled = true;
let iconsVisible = true;
let musicMuted = false;
let gridSize = 4;
let circles = [];
let numbers = [];
let nickname = localStorage.getItem('musubi_nickname') || 'PLAYER';
const themes = ['', 'theme-cyan', 'theme-amber', 'theme-white', 'theme-pink'];
let currentTheme = 0;

// Score system
let currentScore = 0;
let puzzlesSolved = 0;

// Animation state
let animations = [];

// ===== GET THEME COLOR =====
function getColor() {
    return getComputedStyle(document.body).getPropertyValue('--color').trim() || '#4a4';
}

function getBrightColor() {
    return getComputedStyle(document.body).getPropertyValue('--color-bright').trim() || '#5c5';
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{1,2})([a-f\d]{1,2})([a-f\d]{1,2})$/i.exec(hex);
    if (result) {
        return {
            r: parseInt(result[1].length === 1 ? result[1] + result[1] : result[1], 16),
            g: parseInt(result[2].length === 1 ? result[2] + result[2] : result[2], 16),
            b: parseInt(result[3].length === 1 ? result[3] + result[3] : result[3], 16)
        };
    }
    return { r: 68, g: 170, b: 68 };
}

// ===== SCANLINE TEXT RENDERER =====
const BLOCK_FONT = {
    'A': ["01110","10001","10001","11111","10001","10001","10001"],
    'B': ["11110","10001","10001","11110","10001","10001","11110"],
    'C': ["01110","10001","10000","10000","10000","10001","01110"],
    'D': ["11110","10001","10001","10001","10001","10001","11110"],
    'E': ["11111","10000","10000","11110","10000","10000","11111"],
    'F': ["11111","10000","10000","11110","10000","10000","10000"],
    'G': ["01110","10001","10000","10111","10001","10001","01110"],
    'H': ["10001","10001","10001","11111","10001","10001","10001"],
    'I': ["11111","00100","00100","00100","00100","00100","11111"],
    'J': ["00111","00010","00010","00010","00010","10010","01100"],
    'K': ["10001","10010","10100","11000","10100","10010","10001"],
    'L': ["10000","10000","10000","10000","10000","10000","11111"],
    'M': ["10001","11011","10101","10101","10001","10001","10001"],
    'N': ["10001","10001","11001","10101","10011","10001","10001"],
    'O': ["01110","10001","10001","10001","10001","10001","01110"],
    'P': ["11110","10001","10001","11110","10000","10000","10000"],
    'Q': ["01110","10001","10001","10001","10101","10010","01101"],
    'R': ["11110","10001","10001","11110","10100","10010","10001"],
    'S': ["01111","10000","10000","01110","00001","00001","11110"],
    'T': ["11111","00100","00100","00100","00100","00100","00100"],
    'U': ["10001","10001","10001","10001","10001","10001","01110"],
    'V': ["10001","10001","10001","10001","10001","01010","00100"],
    'W': ["10001","10001","10001","10101","10101","10101","01010"],
    'X': ["10001","10001","01010","00100","01010","10001","10001"],
    'Y': ["10001","10001","01010","00100","00100","00100","00100"],
    'Z': ["11111","00001","00010","00100","01000","10000","11111"],
    '0': ["01110","10001","10011","10101","11001","10001","01110"],
    '1': ["00100","01100","00100","00100","00100","00100","01110"],
    '2': ["01110","10001","00001","00010","00100","01000","11111"],
    '3': ["11111","00010","00100","00010","00001","10001","01110"],
    '4': ["00010","00110","01010","10010","11111","00010","00010"],
    '5': ["11111","10000","11110","00001","00001","10001","01110"],
    '6': ["00110","01000","10000","11110","10001","10001","01110"],
    '7': ["11111","00001","00010","00100","01000","01000","01000"],
    '8': ["01110","10001","10001","01110","10001","10001","01110"],
    '9': ["01110","10001","10001","01111","00001","00010","01100"],
    ' ': ["00000","00000","00000","00000","00000","00000","00000"],
    ':': ["00000","00100","00100","00000","00100","00100","00000"],
    '-': ["00000","00000","00000","11111","00000","00000","00000"],
    '.': ["00000","00000","00000","00000","00000","01100","01100"],
};

// Draw text with scanline effect
function drawScanlineText(ctx, text, x, y, pixelSize, color) {
    const chars = text.toUpperCase().split('');
    let offsetX = 0;
    
    chars.forEach(char => {
        const pattern = BLOCK_FONT[char] || BLOCK_FONT[' '];
        pattern.forEach((row, rowIndex) => {
            for (let col = 0; col < row.length; col++) {
                if (row[col] === '1') {
                    // Draw pixel with scanline (skip every other line for effect)
                    for (let py = 0; py < pixelSize; py++) {
                        if (py % 2 === 0) { // Scanline effect
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                x + offsetX + col * pixelSize,
                                y + rowIndex * pixelSize + py,
                                pixelSize,
                                1
                            );
                        }
                    }
                }
            }
        });
        offsetX += 6 * pixelSize;
    });
    
    return offsetX;
}

function getTextWidth(text, pixelSize) {
    return text.length * 6 * pixelSize;
}

function drawCenteredScanlineText(ctx, text, canvasWidth, y, pixelSize, color) {
    const width = getTextWidth(text, pixelSize);
    drawScanlineText(ctx, text, (canvasWidth - width) / 2, y, pixelSize, color);
}

// ===== BIG LOGO WITH SCANLINES =====
const LOGO_LETTERS = {
    'M': [
        [1,0,0,0,0,0,1],
        [1,1,0,0,0,1,1],
        [1,0,1,0,1,0,1],
        [1,0,0,1,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1]
    ],
    'U': [
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [0,1,1,1,1,1,0]
    ],
    'S': [
        [0,1,1,1,1,1,0],
        [1,0,0,0,0,0,0],
        [1,0,0,0,0,0,0],
        [0,1,1,1,1,1,0],
        [0,0,0,0,0,0,1],
        [0,0,0,0,0,0,1],
        [0,1,1,1,1,1,0]
    ],
    'B': [
        [1,1,1,1,1,1,0],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,1,1,1,1,1,0],
        [1,0,0,0,0,0,1],
        [1,0,0,0,0,0,1],
        [1,1,1,1,1,1,0]
    ],
    'I': [
        [1,1,1,1,1],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [1,1,1,1,1]
    ]
};

function drawLogo(ctx, width, height) {
    ctx.clearRect(0, 0, width, height);
    const color = getColor();
    
    const isDesktop = window.innerWidth > 600;
    const blockSize = isDesktop ? 8 : 5;
    const letterGap = isDesktop ? 20 : 12;
    
    const letters = ['M', 'U', 'S', 'U', 'B', 'I'];
    
    // Calculate total width
    let totalWidth = 0;
    letters.forEach((letter, i) => {
        totalWidth += LOGO_LETTERS[letter][0].length * blockSize;
        if (i < letters.length - 1) totalWidth += letterGap;
    });
    
    const totalHeight = 7 * blockSize;
    const startX = Math.round((width - totalWidth) / 2);
    const startY = Math.round((height - totalHeight - 20) / 2);
    
    ctx.fillStyle = color;
    
    let offsetX = startX;
    letters.forEach((letter) => {
        const data = LOGO_LETTERS[letter];
        
        data.forEach((row, rowIndex) => {
            row.forEach((pixel, colIndex) => {
                if (pixel === 1) {
                    const x = offsetX + colIndex * blockSize;
                    const y = startY + rowIndex * blockSize;
                    
                    // Draw with scanlines
                    for (let py = 0; py < blockSize; py++) {
                        if (py % 2 === 0) {
                            ctx.fillRect(x, y + py, blockSize - 1, 1);
                        }
                    }
                }
            });
        });
        
        offsetX += data[0].length * blockSize + letterGap;
    });
    
    // Underlines centered
    const underlineY = startY + totalHeight + 12;
    ctx.fillRect(startX, underlineY, totalWidth, 3);
    ctx.fillRect(startX, underlineY + 6, totalWidth, 2);
    ctx.fillRect(startX, underlineY + 10, totalWidth, 1);
}

// ===== STARS WITH PARALLAX =====
const starsCanvas = document.getElementById('stars-canvas');
const starsCtx = starsCanvas.getContext('2d');

function resizeStars() {
    starsCanvas.width = window.innerWidth;
    starsCanvas.height = window.innerHeight;
    initStars();
}

const starLayers = [
    { stars: [], speed: 0.1, size: 3, count: 12, alpha: 0.2 },
    { stars: [], speed: 0.25, size: 4, count: 10, alpha: 0.3 },
    { stars: [], speed: 0.5, size: 5, count: 8, alpha: 0.45 },
    { stars: [], speed: 0.9, size: 7, count: 5, alpha: 0.6 },
    { stars: [], speed: 1.4, size: 9, count: 3, alpha: 0.8 }
];

function initStars() {
    starLayers.forEach(layer => {
        layer.stars = [];
        for (let i = 0; i < layer.count; i++) {
            layer.stars.push({
                x: Math.random() * starsCanvas.width,
                y: Math.random() * starsCanvas.height
            });
        }
    });
}

resizeStars();
window.addEventListener('resize', resizeStars);

function animateStars() {
    starsCtx.fillStyle = '#000';
    starsCtx.fillRect(0, 0, starsCanvas.width, starsCanvas.height);
    
    if (!starsEnabled) {
        requestAnimationFrame(animateStars);
        return;
    }
    
    const rgb = hexToRgb(getColor());
    
    starLayers.forEach(layer => {
        starsCtx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${layer.alpha})`;
        
        layer.stars.forEach(star => {
            starsCtx.fillRect(Math.floor(star.x), Math.floor(star.y), layer.size, layer.size);
            
            star.y += layer.speed;
            if (star.y > starsCanvas.height + layer.size) {
                star.y = -layer.size * 2;
                star.x = Math.random() * starsCanvas.width;
            }
        });
    });
    
    requestAnimationFrame(animateStars);
}
animateStars();

// ===== ICONS =====

function drawIcon(canvasId, type, active = true) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const color = active ? getColor() : '#333';
    const w = canvas.width;
    const h = canvas.height;
    
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = color;
    
    switch(type) {
        case 'stars':
            // Star shape
            ctx.fillRect(23, 5, 4, 4);
            ctx.fillRect(19, 9, 12, 4);
            ctx.fillRect(11, 13, 28, 4);
            ctx.fillRect(15, 17, 20, 4);
            ctx.fillRect(19, 21, 12, 4);
            ctx.fillRect(15, 25, 8, 4);
            ctx.fillRect(27, 25, 8, 4);
            ctx.fillRect(11, 29, 8, 4);
            ctx.fillRect(31, 29, 8, 4);
            break;
            
        case 'music':
            // Music note
            ctx.fillRect(28, 6, 4, 24);
            ctx.fillRect(32, 6, 10, 3);
            ctx.fillRect(32, 11, 8, 3);
            ctx.fillRect(14, 24, 18, 12);
            break;
            
        case 'home':
            // House
            ctx.fillRect(23, 5, 4, 6);
            ctx.fillRect(15, 11, 20, 4);
            ctx.fillRect(11, 15, 28, 4);
            ctx.fillRect(14, 19, 22, 16);
            ctx.fillStyle = '#000';
            ctx.fillRect(21, 25, 8, 10);
            break;
            
        case 'hamburger':
            // Three lines
            ctx.fillRect(12, 10, 26, 4);
            ctx.fillRect(12, 19, 26, 4);
            ctx.fillRect(12, 28, 26, 4);
            break;
    }
    
    // Apply scanline effect
    const imageData = ctx.getImageData(0, 0, w, h);
    for (let y = 0; y < h; y++) {
        if (y % 2 === 1) {
            for (let x = 0; x < w; x++) {
                const i = (y * w + x) * 4;
                imageData.data[i + 3] = Math.floor(imageData.data[i + 3] * 0.3);
            }
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function drawAllIcons() {
    drawIcon('icon-stars', 'stars', starsEnabled);
    drawIcon('icon-music', 'music', !musicMuted);
    drawIcon('icon-home', 'home', true);
}

// ===== SCREENS =====
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id + '-screen').classList.add('active');
    
    switch(id) {
        case 'menu': drawMenuScreen(); break;
        case 'difficulty': drawDifficultyScreen(); break;
        case 'game': drawGameScreen(); break;
        case 'howto': drawHowtoScreen(); break;
        case 'nickname': drawNicknameScreen(); break;
        case 'leaderboard': drawLeaderboardScreen(); break;
    }
}

function drawMenuScreen() {
    const color = getColor();
    
    // Le logo est maintenant une image, pas besoin de le dessiner
    
    const items = [
        ['menu-newgame', 'NEW GAME'],
        ['menu-leaderboard', 'LEADERBOARD'],
        ['menu-nickname', 'YOUR NICKNAME'],
        ['menu-howto', 'HOW TO PLAY'],
        ['menu-color', 'COLOR']
    ];
    
    items.forEach(([id, text]) => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCenteredScanlineText(ctx, text, canvas.width, 12, 3, color);
    });
}

function drawDifficultyScreen() {
    const color = getColor();
    
    const titleCanvas = document.getElementById('diff-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 300, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'SELECT MODE', 300, 10, 4, color);
    
    const items = [
        ['diff-training', 'TRAINING  4X4'],
        ['diff-challenge', 'CHALLENGE  5X5'],
        ['diff-expert', 'EXPERT  6X6'],
        ['diff-back', 'BACK']
    ];
    
    items.forEach(([id, text]) => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCenteredScanlineText(ctx, text, canvas.width, 12, 3, color);
    });
}

function drawGameScreen() {
    drawAllIcons();
    drawPuzzle();
    
    const modeCanvas = document.getElementById('mode-canvas');
    const ctx = modeCanvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 40);
    
    const modeNames = { 4: 'Training', 5: 'Challenge', 6: 'Expert' };
    const displayText = modeNames[gridSize] + '  ' + currentScore + ' PTS';
    drawCenteredScanlineText(ctx, displayText, 400, 10, 3, getColor());
}

function drawHowtoScreen() {
    const color = getColor();
    
    const titleCanvas = document.getElementById('howto-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 280, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'HOW TO PLAY', 280, 10, 4, color);
    
    const contentCanvas = document.getElementById('howto-content');
    const ctx = contentCanvas.getContext('2d');
    ctx.clearRect(0, 0, 340, 320);
    
    const lines = [
        'TAP CIRCLES TO',
        'FILL THEM',
        '',
        'EACH NUMBER SHOWS',
        'HOW MANY NEIGHBORS',
        'ARE FILLED',
        '',
        'MATCH ALL NUMBERS',
        'TO WIN'
    ];
    
    lines.forEach((line, i) => {
        if (line) {
            drawCenteredScanlineText(ctx, line, 340, 5 + i * 34, 3, color);
        }
    });
    
    const backCanvas = document.getElementById('howto-back');
    backCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(backCanvas.getContext('2d'), 'BACK', 120, 10, 3, color);
}

function drawNicknameScreen() {
    const color = getColor();
    
    const titleCanvas = document.getElementById('nickname-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 320, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'YOUR NICKNAME', 320, 10, 4, color);
    
    document.getElementById('nickname-input').style.color = color;
    document.getElementById('nickname-input').style.borderColor = color;
    document.getElementById('nickname-input').value = nickname;
    
    const saveCanvas = document.getElementById('nickname-save');
    saveCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(saveCanvas.getContext('2d'), 'SAVE', 120, 10, 3, color);
    
    const backCanvas = document.getElementById('nickname-back');
    backCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(backCanvas.getContext('2d'), 'BACK', 120, 10, 3, color);
}

function drawLeaderboardScreen() {
    const color = getColor();
    
    const titleCanvas = document.getElementById('leaderboard-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 300, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'LEADERBOARD', 300, 10, 4, color);
    
    const listCanvas = document.getElementById('leaderboard-list');
    const ctx = listCanvas.getContext('2d');
    ctx.clearRect(0, 0, 380, 400);
    
    // Afficher "Loading..."
    drawCenteredScanlineText(ctx, 'LOADING...', 380, 180, 3, color);
    
    // Charger les scores depuis Google Sheets
    fetchLeaderboard().then(scores => {
        ctx.clearRect(0, 0, 380, 400);
        
        if (scores.length === 0) {
            drawCenteredScanlineText(ctx, 'NO SCORES YET', 380, 180, 3, color);
        } else {
            scores.forEach((entry, i) => {
                const y = 15 + i * 38;
                drawScanlineText(ctx, (i + 1) + '.', 10, y, 3, color);
                drawScanlineText(ctx, entry.nickname, 60, y, 3, color);
                drawScanlineText(ctx, entry.score.toString(), 280, y, 3, color);
            });
        }
    });
    
    const backCanvas = document.getElementById('leaderboard-back');
    backCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(backCanvas.getContext('2d'), 'BACK', 120, 10, 3, color);
}

// ===== LEADERBOARD API =====
const LEADERBOARD_URL = 'https://script.google.com/macros/s/AKfycbzwwGm8kGbcjixpMpR3xhfH4gofyMPY1kXnPdcGzl4tnrJz7ewgVDH2J825Lhh93940/exec';

async function fetchLeaderboard() {
    try {
        const response = await fetch(LEADERBOARD_URL, {
            method: 'GET',
            redirect: 'follow'
        });
        const data = await response.json();
        console.log('Leaderboard data:', data);
        // Combiner tous les modes et trier
        const all = [...(data.training || []), ...(data.challenge || []), ...(data.expert || [])];
        all.sort((a, b) => b.score - a.score);
        return all.slice(0, 10);
    } catch (e) {
        console.error('Leaderboard fetch error:', e);
        return [];
    }
}

async function submitScore(score, mode) {
    if (score <= 0) return;
    
    try {
        const modeNames = { 4: 'training', 5: 'challenge', 6: 'expert' };
        const params = new URLSearchParams({
            nickname: nickname,
            score: score,
            mode: modeNames[mode] || 'training'
        });
        
        const url = LEADERBOARD_URL + '?action=submit&' + params.toString();
        console.log('Submitting score to:', url);
        
        // Utiliser GET avec params pour contourner CORS
        const response = await fetch(url, {
            method: 'GET',
            redirect: 'follow'
        });
        const result = await response.text();
        console.log('Score submitted:', score, nickname, 'Response:', result);
    } catch (e) {
        console.error('Score submit error:', e);
    }
}

// ===== PUZZLE =====
function generatePuzzle() {
    circles = [];
    for (let y = 0; y < gridSize; y++) {
        circles[y] = [];
        for (let x = 0; x < gridSize; x++) {
            circles[y][x] = {
                filled: false,
                solution: Math.random() < 0.35
            };
        }
    }
    
    numbers = [];
    for (let y = 0; y < gridSize - 1; y++) {
        numbers[y] = [];
        for (let x = 0; x < gridSize - 1; x++) {
            let count = 0;
            if (circles[y][x].solution) count++;
            if (circles[y][x + 1].solution) count++;
            if (circles[y + 1][x].solution) count++;
            if (circles[y + 1][x + 1].solution) count++;
            numbers[y][x] = count;
        }
    }
}

function drawPuzzle() {
    const canvas = document.getElementById('puzzle-canvas');
    const ctx = canvas.getContext('2d');
    const color = getColor();
    const brightColor = getBrightColor();
    
    // Responsive size - bigger on desktop
    const maxSize = Math.min(500, window.innerWidth - 40, window.innerHeight - 250);
    const size = Math.max(280, maxSize);
    canvas.width = size;
    canvas.height = size;
    
    const cellSize = size / gridSize;
    const circleRadius = cellSize * 0.22;
    const lineWidth = Math.max(4, Math.floor(size / 100));
    
    ctx.clearRect(0, 0, size, size);
    
    // Draw lines with scanline effect
    ctx.fillStyle = color;
    
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cx = x * cellSize + cellSize / 2;
            const cy = y * cellSize + cellSize / 2;
            
            // Horizontal line
            if (x < gridSize - 1) {
                const nextCx = (x + 1) * cellSize + cellSize / 2;
                for (let py = 0; py < lineWidth; py++) {
                    if (py % 2 === 0) {
                        ctx.fillRect(cx + circleRadius, cy - lineWidth/2 + py, nextCx - cx - circleRadius * 2, 1);
                    }
                }
            }
            
            // Vertical line
            if (y < gridSize - 1) {
                const nextCy = (y + 1) * cellSize + cellSize / 2;
                for (let px = 0; px < lineWidth; px++) {
                    if (px % 2 === 0) {
                        ctx.fillRect(cx - lineWidth/2 + px, cy + circleRadius, 1, nextCy - cy - circleRadius * 2);
                    }
                }
            }
        }
    }
    
    // Draw numbers with scanlines
    for (let y = 0; y < gridSize - 1; y++) {
        for (let x = 0; x < gridSize - 1; x++) {
            const cx = (x + 1) * cellSize;
            const cy = (y + 1) * cellSize;
            const num = numbers[y][x].toString();
            const textWidth = getTextWidth(num, 4);
            drawScanlineText(ctx, num, cx - textWidth / 2, cy - 14, 4, brightColor);
        }
    }
    
    // Draw circles with scanlines
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cx = x * cellSize + cellSize / 2;
            const cy = y * cellSize + cellSize / 2;
            
            // Check for animation on this circle
            const anim = animations.find(a => a.x === x && a.y === y);
            let animScale = 1;
            let animAlpha = 0;
            
            if (anim) {
                const progress = anim.progress;
                animScale = 1 + Math.sin(progress * Math.PI) * 0.2;
                animAlpha = Math.sin(progress * Math.PI) * 0.6;
            }
            
            const currentRadius = circleRadius * animScale;
            
            if (circles[y][x].filled) {
                // Filled circle with scanlines
                ctx.fillStyle = color;
                for (let dy = -currentRadius; dy <= currentRadius; dy++) {
                    if (Math.floor(cy + dy) % 2 === 0) {
                        const width = Math.sqrt(currentRadius * currentRadius - dy * dy);
                        ctx.fillRect(cx - width, cy + dy, width * 2, 1);
                    }
                }
                
                // Glow effect during animation
                if (animAlpha > 0) {
                    const rgb = hexToRgb(color);
                    ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${animAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, currentRadius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else {
                // Empty circle - draw thick pixelated outline with scanlines
                ctx.fillStyle = color;
                const thickness = 4;
                for (let t = 0; t < thickness; t++) {
                    const r = currentRadius - t;
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.03) {
                        const px = cx + Math.cos(angle) * r;
                        const py = cy + Math.sin(angle) * r;
                        
                        // Only draw on even rows for scanline effect
                        if (Math.floor(py) % 2 === 0) {
                            ctx.fillRect(Math.floor(px), Math.floor(py), 2, 1);
                        }
                    }
                }
            }
        }
    }
}

// Animation loop for circles
function updateAnimations() {
    if (animations.length > 0) {
        animations.forEach(anim => {
            anim.progress += 0.08;
        });
        animations = animations.filter(a => a.progress < 1);
        drawPuzzle();
    }
    requestAnimationFrame(updateAnimations);
}
updateAnimations();

function triggerCircleAnimation(x, y) {
    // Remove any existing animation on this circle
    animations = animations.filter(a => !(a.x === x && a.y === y));
    animations.push({ x, y, progress: 0 });
}

function checkWin() {
    for (let y = 0; y < gridSize - 1; y++) {
        for (let x = 0; x < gridSize - 1; x++) {
            let count = 0;
            if (circles[y][x].filled) count++;
            if (circles[y][x + 1].filled) count++;
            if (circles[y + 1][x].filled) count++;
            if (circles[y + 1][x + 1].filled) count++;
            if (count !== numbers[y][x]) return false;
        }
    }
    return true;
}

// ===== EVENT LISTENERS =====
document.getElementById('menu-newgame').addEventListener('click', () => showScreen('difficulty'));
document.getElementById('menu-leaderboard').addEventListener('click', () => showScreen('leaderboard'));
document.getElementById('menu-nickname').addEventListener('click', () => showScreen('nickname'));
document.getElementById('menu-howto').addEventListener('click', () => showScreen('howto'));
document.getElementById('menu-color').addEventListener('click', () => {
    currentTheme = (currentTheme + 1) % themes.length;
    document.body.className = themes[currentTheme];
    drawMenuScreen();
});

document.getElementById('diff-training').addEventListener('click', () => startGame(4));
document.getElementById('diff-challenge').addEventListener('click', () => startGame(5));
document.getElementById('diff-expert').addEventListener('click', () => startGame(6));
document.getElementById('diff-back').addEventListener('click', () => showScreen('menu'));

// Game icons - these exist in DOM even when hidden
const iconHome = document.getElementById('icon-home');
const iconStars = document.getElementById('icon-stars');
const iconMusic = document.getElementById('icon-music');

if (iconHome) iconHome.addEventListener('click', () => {
    // Soumettre le score si on a joué
    if (currentScore > 0) {
        submitScore(currentScore, gridSize);
        currentScore = 0;
        puzzlesSolved = 0;
    }
    // Arrêter la musique
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicStarted = false;
    const eq = document.getElementById('equalizer');
    if (eq) eq.classList.add('paused');
    
    showScreen('menu');
});
if (iconStars) iconStars.addEventListener('click', () => {
    starsEnabled = !starsEnabled;
    drawIcon('icon-stars', 'stars', starsEnabled);
});
if (iconMusic) iconMusic.addEventListener('click', () => {
    musicMuted = !musicMuted;
    bgMusic.muted = musicMuted;
    drawIcon('icon-music', 'music', !musicMuted);
    // Contrôler l'equalizer
    const eq = document.getElementById('equalizer');
    if (eq) {
        if (musicMuted) {
            eq.classList.add('paused');
        } else {
            eq.classList.remove('paused');
        }
    }
});

document.getElementById('howto-back').addEventListener('click', () => showScreen('menu'));
document.getElementById('nickname-save').addEventListener('click', () => {
    nickname = document.getElementById('nickname-input').value.toUpperCase() || 'PLAYER';
    localStorage.setItem('musubi_nickname', nickname);
    showScreen('menu');
});
document.getElementById('nickname-back').addEventListener('click', () => showScreen('menu'));
document.getElementById('leaderboard-back').addEventListener('click', () => showScreen('menu'));

document.getElementById('puzzle-canvas').addEventListener('click', (e) => {
    const canvas = document.getElementById('puzzle-canvas');
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    const cellSize = canvas.width / gridSize;
    const gridX = Math.floor(x / cellSize);
    const gridY = Math.floor(y / cellSize);
    
    if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
        circles[gridY][gridX].filled = !circles[gridY][gridX].filled;
        triggerCircleAnimation(gridX, gridY);
        drawPuzzle();
        
        if (checkWin()) {
            // Calculer les points (plus de points pour les grandes grilles)
            const points = gridSize * gridSize * 100;
            currentScore += points;
            puzzlesSolved++;
            
            // Mettre à jour l'affichage du score immédiatement
            const modeCanvas = document.getElementById('mode-canvas');
            const ctx = modeCanvas.getContext('2d');
            ctx.clearRect(0, 0, 400, 40);
            const modeNames = { 4: 'Training', 5: 'Challenge', 6: 'Expert' };
            const displayText = modeNames[gridSize] + '  ' + currentScore + ' PTS';
            drawCenteredScanlineText(ctx, displayText, 400, 10, 3, getColor());
            
            setTimeout(() => {
                generatePuzzle();
                drawPuzzle();
            }, 500);
        }
    }
});

function startGame(size) {
    gridSize = size;
    currentScore = 0;
    puzzlesSolved = 0;
    generatePuzzle();
    showScreen('game');
    // Démarrer la musique quand on lance une partie
    startMusicWithFade();
}

// ===== AUDIO =====
// Playlist de musiques
const musicTracks = [
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music1.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music2.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music3.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music4.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music5.mp3'
];
let currentTrack = 0;

const bgMusic = new Audio(musicTracks[0]);
bgMusic.loop = true;
bgMusic.volume = 0.5;

const beepSound = new Audio('https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/beepMenuChoice.mp3');
beepSound.volume = 0.3;

// Web Audio API pour moins de latence sur mobile
let audioContext = null;
let beepBuffer = null;

async function initAudioContext() {
    if (audioContext) return;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch('https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/beepMenuChoice.mp3');
        const arrayBuffer = await response.arrayBuffer();
        beepBuffer = await audioContext.decodeAudioData(arrayBuffer);
    } catch (e) {
        console.log('Web Audio API not available, using fallback');
    }
}

let musicStarted = false;

function playBeep() {
    // Utiliser Web Audio API si disponible (plus rapide)
    if (audioContext && beepBuffer) {
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 0.3;
        source.buffer = beepBuffer;
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        source.start(0);
    } else {
        // Fallback sur Audio standard
        beepSound.currentTime = 0;
        beepSound.play().catch(() => {});
    }
}

// Initialiser l'audio au premier clic (requis sur mobile)
document.addEventListener('click', () => {
    initAudioContext();
}, { once: true });

function nextTrack() {
    if (musicTracks.length <= 1) return;
    
    currentTrack = (currentTrack + 1) % musicTracks.length;
    bgMusic.src = musicTracks[currentTrack];
    bgMusic.play().catch(() => {});
}

function startMusicWithFade() {
    if (!musicStarted) {
        bgMusic.volume = 0;
        bgMusic.play().then(() => {
            musicStarted = true;
            // Activer l'equalizer
            const eq = document.getElementById('equalizer');
            if (eq && !musicMuted) eq.classList.remove('paused');
            // Fondu de 0 à 0.5 en 2 secondes
            let vol = 0;
            const fadeIn = setInterval(() => {
                vol += 0.02;
                if (vol >= 0.5) {
                    vol = 0.5;
                    clearInterval(fadeIn);
                }
                if (!musicMuted) bgMusic.volume = vol;
            }, 80);
        }).catch(() => {});
    }
}

// Clic sur l'equalizer = musique suivante
document.getElementById('equalizer').addEventListener('click', () => {
    nextTrack();
});

// Ajouter le beep à tous les clics sur menu-item
document.addEventListener('click', (e) => {
    // Jouer le beep sur les éléments cliquables
    if (e.target.classList.contains('menu-item') || e.target.classList.contains('top-icon')) {
        playBeep();
    }
});

// ===== PRELOADER =====
const preloader = document.getElementById('preloader');
const preloaderBar = document.getElementById('preloader-bar');
const gameContainer = document.getElementById('game-container');

const assetsToLoad = 3; // logo + 2 sons

let loadedCount = 0;
let preloaderDone = false;

function updateProgress() {
    if (preloaderDone) return;
    loadedCount++;
    const percent = (loadedCount / assetsToLoad) * 100;
    preloaderBar.style.width = percent + '%';
    
    if (loadedCount >= assetsToLoad) {
        finishPreloader();
    }
}

function finishPreloader() {
    if (preloaderDone) return;
    preloaderDone = true;
    preloaderBar.style.width = '100%';
    setTimeout(() => {
        preloader.style.display = 'none';
        gameContainer.style.display = 'flex';
        drawMenuScreen();
    }, 300);
}

// Charger le logo (déjà dans le HTML, on attend juste qu'il soit prêt)
const logoImg = document.getElementById('logo-img');
if (logoImg.complete) {
    updateProgress();
} else {
    logoImg.onload = updateProgress;
    logoImg.onerror = updateProgress;
}

// Charger la musique - plusieurs événements pour compatibilité mobile
let musicLoaded = false;
function onMusicLoad() {
    if (!musicLoaded) {
        musicLoaded = true;
        updateProgress();
    }
}
bgMusic.oncanplaythrough = onMusicLoad;
bgMusic.onloadeddata = onMusicLoad;
bgMusic.onerror = onMusicLoad;

// Charger le beep
let beepLoaded = false;
function onBeepLoad() {
    if (!beepLoaded) {
        beepLoaded = true;
        updateProgress();
    }
}
beepSound.oncanplaythrough = onBeepLoad;
beepSound.onloadeddata = onBeepLoad;
beepSound.onerror = onBeepLoad;

// Timeout de sécurité - si après 5 secondes c'est pas chargé, on lance quand même
setTimeout(() => {
    if (!preloaderDone) {
        console.log('Preloader timeout - forcing start');
        finishPreloader();
    }
}, 5000);
</script>
</body>
</html>