<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MUSUBI</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAuElEQVR4nGNgGAVDHfDL8f+nRD8jrSz7+OgjUWYT7YCUOykk+3SOyhyC5hNUQI7FpDiEidaWEzIHp8soTVzYALZ0gTcE6AGwhgC1gh4bQE8PGCFAS8uxmT/4ooAWiQ8dICfGAQ8BFnSB0H2hNLd0jsocOBslBGidALHZg+IAYspuagBke0YT4eBKhAMBMBxA64SIbv5odYw3uKlZMOGKWrwhQK30gM+cwd8qRga06BdQDOhRdA9vAABjbkwqWmLx7QAAAABJRU5ErkJggg==">
    <!-- Open Graph / Twitter -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="MUSUBI">
    <meta property="og:description" content="A retro logic puzzle game. Fill the circles to match the numbers!">
    <meta property="og:image" content="https://raw.githubusercontent.com/DNSZLSK/musubi/master/Images/musubi%20logo%204.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="MUSUBI">
    <meta name="twitter:description" content="A retro logic puzzle game. Fill the circles to match the numbers!">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #000;
    overflow: hidden;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    --color: #5c5;
    --color-bright: #7f7;
}
body.theme-cyan  { --color: #5cc; --color-bright: #7ee; }
body.theme-amber { --color: #ca6; --color-bright: #ec8; }
body.theme-white { --color: #bbb; --color-bright: #ddd; }
body.theme-pink  { --color: #c5c; --color-bright: #e7e; }
#stars-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
}
#game-container {
    position: relative;
    z-index: 2;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
.screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%; height: 100%;
    animation: fadeIn 0.3s ease-out;
}
.screen.active { display: flex; }
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
#menu-screen { justify-content: center; gap: 5px; }
#difficulty-screen,
#howto-screen,
#nickname-screen,
#leaderboard-screen,
#gameover-screen {
    justify-content: space-between;
    padding: 60px 20px 40px;
}
.content {
    display: flex;
    flex-direction: column;
    align-items: center;
}
#logo-img {
    width: 650px;
    max-width: 95%;
    height: auto;
    margin-bottom: 10px;
    filter: drop-shadow(0 0 10px rgba(74,170,74,0.4));
}
body.theme-cyan #logo-img  { filter: hue-rotate(160deg) drop-shadow(0 0 10px rgba(74,170,170,0.4)); }
body.theme-amber #logo-img { filter: hue-rotate(-80deg) saturate(1.2) drop-shadow(0 0 10px rgba(170,136,74,0.4)); }
body.theme-white #logo-img { filter: saturate(0) brightness(1.3) drop-shadow(0 0 10px rgba(150,150,150,0.4)); }
body.theme-pink #logo-img  { filter: hue-rotate(280deg) drop-shadow(0 0 10px rgba(170,74,170,0.4)); }
#credits-footer {
    position: absolute;
    bottom: 15px;
    font-family: monospace;
    font-size: 10px;
    color: #333;
    letter-spacing: 1px;
}
.menu-item {
    cursor: pointer;
    margin: 8px 0;
    transition: transform 0.1s, filter 0.2s;
    filter: drop-shadow(0 0 2px var(--color));
}
@media (hover: hover) {
    .menu-item:hover {
        filter: drop-shadow(0 0 4px var(--color)) drop-shadow(0 0 10px var(--color));
    }
}
.menu-item:active { transform: scale(0.95); }
#game-screen {
    padding: 20px;
    justify-content: flex-start;
    padding-top: 80px;
}
#top-bar {
    position: absolute;
    top: 15px; left: 15px; right: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#top-icons { display: flex; gap: 15px; }
#top-right { display: flex; align-items: center; gap: 15px; }
.top-icon {
    cursor: pointer;
    transition: filter 0.2s;
    filter: drop-shadow(0 0 2px var(--color));
}
@media (hover: hover) {
    .top-icon:hover {
        filter: drop-shadow(0 0 4px var(--color)) drop-shadow(0 0 10px var(--color));
    }
}
#puzzle-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 100%;
}
#puzzle-canvas {
    max-width: 100%;
    filter: drop-shadow(0 0 3px var(--color));
}
#mode-canvas {
    margin-top: 25px;
    filter: drop-shadow(0 0 5px var(--color)) drop-shadow(0 0 12px var(--color));
}
#timer-canvas {
    filter: drop-shadow(0 0 8px var(--color));
}
#equalizer {
    display: flex;
    align-items: flex-end;
    gap: 3px;
    height: 25px;
}
#equalizer.paused .eq-bar {
    animation-play-state: paused;
    height: 5px !important;
}
.eq-bar {
    width: 4px;
    background: var(--color);
    animation: equalize 0.8s ease-in-out infinite;
}
.eq-bar:nth-child(1) { animation-delay: 0s; }
.eq-bar:nth-child(2) { animation-delay: 0.2s; }
.eq-bar:nth-child(3) { animation-delay: 0.4s; }
.eq-bar:nth-child(4) { animation-delay: 0.1s; }
@keyframes equalize {
    0%, 100% { height: 5px; }
    50% { height: 20px; }
}
.leaderboard-nav {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 15px;
}
.nav-arrow {
    cursor: pointer;
    transition: filter 0.2s, transform 0.1s;
    filter: drop-shadow(0 0 2px var(--color));
}
@media (hover: hover) {
    .nav-arrow:hover {
        filter: drop-shadow(0 0 6px var(--color)) drop-shadow(0 0 12px var(--color));
    }
}
.nav-arrow:active { transform: scale(0.9); }
#nickname-input-canvas {
    cursor: text;
    margin: 20px 0;
}
#hidden-input {
    position: absolute;
    left: -9999px;
    opacity: 0;
}
#preloader {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}
#preloader-canvas {
    filter: drop-shadow(0 0 8px rgba(92,204,92,0.5));
}
#preloader::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
    pointer-events: none;
    z-index: 1;
}
#preloader::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(92,204,92,0.03);
    animation: flicker 0.15s infinite;
    pointer-events: none;
    z-index: 2;
}
@keyframes flicker {
    0% { opacity: 0.27; }
    50% { opacity: 0.26; }
    100% { opacity: 0.27; }
}
</style>
</head>
<body>
    <!-- Hidden input for mobile keyboard -->
    <input type="text" id="hidden-input" maxlength="10" autocomplete="off">
    <!-- Preloader -->
    <div id="preloader">
        <canvas id="preloader-canvas" width="300" height="120"></canvas>
    </div>
    <!-- Stars background -->
    <canvas id="stars-canvas"></canvas>
    <!-- Game container -->
    <div id="game-container" style="display:none;">
        <div id="menu-screen" class="screen active">
            <img id="logo-img" src="https://raw.githubusercontent.com/DNSZLSK/musubi/master/Images/musubi%20logo%204.png" alt="MUSUBI">
            <canvas class="menu-item" id="menu-newgame" width="220" height="45"></canvas>
            <canvas class="menu-item" id="menu-leaderboard" width="280" height="45"></canvas>
            <canvas class="menu-item" id="menu-nickname" width="320" height="45"></canvas>
            <canvas class="menu-item" id="menu-howto" width="260" height="45"></canvas>
            <canvas class="menu-item" id="menu-color" width="160" height="45" style="margin-top:15px;"></canvas>
            <div id="credits-footer">Inspired by Glyn</div>
        </div>
        <div id="difficulty-screen" class="screen">
            <canvas id="diff-title" width="300" height="50"></canvas>
            <div class="content">
                <canvas class="menu-item" id="chrono-toggle" width="340" height="45"></canvas>
                <canvas class="menu-item" id="diff-training" width="340" height="45"></canvas>
                <canvas class="menu-item" id="diff-challenge" width="360" height="45"></canvas>
                <canvas class="menu-item" id="diff-expert" width="300" height="45"></canvas>
            </div>
            <canvas class="menu-item" id="diff-back" width="120" height="40"></canvas>
        </div>
        <div id="game-screen" class="screen">
            <div id="top-bar">
                <div id="top-icons">
                    <canvas class="top-icon" id="icon-stars" width="50" height="45"></canvas>
                    <canvas class="top-icon" id="icon-music" width="50" height="45"></canvas>
                    <canvas class="top-icon" id="icon-home" width="50" height="45"></canvas>
                </div>
                <div id="top-right">
                    <canvas id="timer-canvas" width="140" height="40" style="display:none;"></canvas>
                    <div id="equalizer" class="paused" style="cursor:pointer;">
                        <div class="eq-bar"></div>
                        <div class="eq-bar"></div>
                        <div class="eq-bar"></div>
                        <div class="eq-bar"></div>
                    </div>
                </div>
            </div>
            <div id="puzzle-container">
                <canvas id="puzzle-canvas" width="340" height="340"></canvas>
                <canvas id="mode-canvas" width="400" height="40"></canvas>
            </div>
        </div>
        <div id="howto-screen" class="screen">
            <canvas id="howto-title" width="280" height="50"></canvas>
            <div class="content">
                <canvas id="howto-content" width="340" height="320"></canvas>
            </div>
            <canvas class="menu-item" id="howto-back" width="120" height="40"></canvas>
        </div>
        <div id="nickname-screen" class="screen">
            <canvas id="nickname-title" width="320" height="50"></canvas>
            <div class="content">
                <canvas id="nickname-input-canvas" width="280" height="50"></canvas>
                <canvas class="menu-item" id="nickname-save" width="120" height="40"></canvas>
            </div>
            <canvas class="menu-item" id="nickname-back" width="120" height="40"></canvas>
        </div>
        <div id="leaderboard-screen" class="screen">
            <canvas id="leaderboard-title" width="300" height="50"></canvas>
            <div class="content">
                <div class="leaderboard-nav" style="justify-content:center;">
                    <canvas id="lb-chrono-title" width="280" height="45" class="menu-item" style="margin:0;"></canvas>
                </div>
                <div class="leaderboard-nav">
                    <canvas class="nav-arrow" id="lb-prev" width="40" height="40"></canvas>
                    <canvas id="lb-mode-title" width="280" height="35"></canvas>
                    <canvas class="nav-arrow" id="lb-next" width="40" height="40"></canvas>
                </div>
                <canvas id="leaderboard-list" width="380" height="350"></canvas>
            </div>
            <canvas class="menu-item" id="leaderboard-back" width="120" height="40"></canvas>
        </div>
        <div id="gameover-screen" class="screen">
            <canvas id="gameover-title" width="280" height="50"></canvas>
            <div class="content">
                <canvas id="gameover-score" width="380" height="120"></canvas>
                <canvas class="menu-item" id="gameover-restart" width="200" height="45"></canvas>
                <canvas class="menu-item" id="gameover-menu" width="120" height="45"></canvas>
            </div>
        </div>
    </div>
<script>

let starsOn = true;
let musicOff = false;
let gridSize = 4;
let curScore = 0;
let solved = 0;
let circles = [];
let numbers = [];
let anims = [];
let nickname = localStorage.getItem('musubi_nickname') || 'PLAYER';
let nickIn = '';
let nickAct = false;
const themes = ['', 'theme-cyan', 'theme-amber', 'theme-white', 'theme-pink'];
let curTheme = 0;
let chronoOn = false;
const chronoTime = 120; 
let chronoRem = 0;
let chronoInt = null;
let chronoAct = false;
const lbModes = ['training', 'challenge', 'expert'];
let curLbMode = 0;
let curLbChrono = 0;
let lbData = {
    training: [], challenge: [], expert: [],
    training_chrono: [], challenge_chrono: [], expert_chrono: []
};

function getColor() {
    return getComputedStyle(document.body).getPropertyValue('--color').trim() || '#4a4';
}
function getBrightColor() {
    return getComputedStyle(document.body).getPropertyValue('--color-bright').trim() || '#5c5';
}
function hexToRgb(hex) {
    const r = /^#?([a-f\d]{1,2})([a-f\d]{1,2})([a-f\d]{1,2})$/i.exec(hex);
    return r ? {
        r: parseInt(r[1].length === 1 ? r[1] + r[1] : r[1], 16),
        g: parseInt(r[2].length === 1 ? r[2] + r[2] : r[2], 16),
        b: parseInt(r[3].length === 1 ? r[3] + r[3] : r[3], 16)
    } : { r: 68, g: 170, b: 68 };
}
function fmtScore(n) {
    return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
}

const BLOCK_FONT = {
    'A':["01110","10001","10001","11111","10001","10001","10001"],
    'B':["11110","10001","10001","11110","10001","10001","11110"],
    'C':["01110","10001","10000","10000","10000","10001","01110"],
    'D':["11110","10001","10001","10001","10001","10001","11110"],
    'E':["11111","10000","10000","11110","10000","10000","11111"],
    'F':["11111","10000","10000","11110","10000","10000","10000"],
    'G':["01110","10001","10000","10111","10001","10001","01110"],
    'H':["10001","10001","10001","11111","10001","10001","10001"],
    'I':["11111","00100","00100","00100","00100","00100","11111"],
    'J':["00111","00010","00010","00010","00010","10010","01100"],
    'K':["10001","10010","10100","11000","10100","10010","10001"],
    'L':["10000","10000","10000","10000","10000","10000","11111"],
    'M':["10001","11011","10101","10101","10001","10001","10001"],
    'N':["10001","10001","11001","10101","10011","10001","10001"],
    'O':["01110","10001","10001","10001","10001","10001","01110"],
    'P':["11110","10001","10001","11110","10000","10000","10000"],
    'Q':["01110","10001","10001","10001","10101","10010","01101"],
    'R':["11110","10001","10001","11110","10100","10010","10001"],
    'S':["01111","10000","10000","01110","00001","00001","11110"],
    'T':["11111","00100","00100","00100","00100","00100","00100"],
    'U':["10001","10001","10001","10001","10001","10001","01110"],
    'V':["10001","10001","10001","10001","10001","01010","00100"],
    'W':["10001","10001","10001","10101","10101","10101","01010"],
    'X':["10001","10001","01010","00100","01010","10001","10001"],
    'Y':["10001","10001","01010","00100","00100","00100","00100"],
    'Z':["11111","00001","00010","00100","01000","10000","11111"],
    '0':["01110","10001","10011","10101","11001","10001","01110"],
    '1':["00100","01100","00100","00100","00100","00100","01110"],
    '2':["01110","10001","00001","00010","00100","01000","11111"],
    '3':["11111","00010","00100","00010","00001","10001","01110"],
    '4':["00010","00110","01010","10010","11111","00010","00010"],
    '5':["11111","10000","11110","00001","00001","10001","01110"],
    '6':["00110","01000","10000","11110","10001","10001","01110"],
    '7':["11111","00001","00010","00100","01000","01000","01000"],
    '8':["01110","10001","10001","01110","10001","10001","01110"],
    '9':["01110","10001","10001","01111","00001","00010","01100"],
    ' ':["00000","00000","00000","00000","00000","00000","00000"],
    ':':["00000","00100","00100","00000","00100","00100","00000"],
    '-':["00000","00000","00000","11111","00000","00000","00000"],
    '.':["00000","00000","00000","00000","00000","01100","01100"],
    '<':["00010","00100","01000","10000","01000","00100","00010"],
    '>':["01000","00100","00010","00001","00010","00100","01000"],
    '_':["00000","00000","00000","00000","00000","00000","11111"]
};
function drawScanlineText(ctx, text, x, y, ps, color) {
    const chars = text.toUpperCase().split('');
    let ox = 0;
    chars.forEach(char => {
        const p = BLOCK_FONT[char] || BLOCK_FONT[' '];
        p.forEach((row, ri) => {
            for (let c = 0; c < row.length; c++) {
                if (row[c] === '1') {
                    for (let py = 0; py < ps; py++) {
                        if (py % 2 === 0) {
                            ctx.fillStyle = color;
                            ctx.fillRect(x + ox + c * ps, y + ri * ps + py, ps, 1);
                        }
                    }
                }
            }
        });
        ox += 6 * ps;
    });
    return ox;
}
function getTextWidth(text, ps) {
    return text.length * 6 * ps;
}
function drawCenteredScanlineText(ctx, text, cw, y, ps, color) {
    const w = getTextWidth(text, ps);
    drawScanlineText(ctx, text, (cw - w) / 2, y, ps, color);
}

const starsCanvas = document.getElementById('stars-canvas');
const starsCtx = starsCanvas.getContext('2d');
const starLayers = [
    { stars: [], speed: 0.1, size: 3, count: 12, alpha: 0.2 },
    { stars: [], speed: 0.25, size: 4, count: 10, alpha: 0.3 },
    { stars: [], speed: 0.5, size: 5, count: 8, alpha: 0.45 },
    { stars: [], speed: 0.9, size: 7, count: 5, alpha: 0.6 },
    { stars: [], speed: 1.4, size: 9, count: 3, alpha: 0.8 }
];
function initStars() {
    starLayers.forEach(layer => {
        layer.stars = [];
        for (let i = 0; i < layer.count; i++) {
            layer.stars.push({
                x: Math.random() * starsCanvas.width,
                y: Math.random() * starsCanvas.height
            });
        }
    });
}
function resizeStars() {
    starsCanvas.width = window.innerWidth;
    starsCanvas.height = window.innerHeight;
    initStars();
}
function animateStars() {
    starsCtx.fillStyle = '#000';
    starsCtx.fillRect(0, 0, starsCanvas.width, starsCanvas.height);
    if (!starsOn) {
        requestAnimationFrame(animateStars);
        return;
    }
    const rgb = hexToRgb(getColor());
    const cx = starsCanvas.width / 2;
    const cy = starsCanvas.height / 2;
    const gz = Math.min(starsCanvas.width, starsCanvas.height) * 0.3;
    const gs = document.getElementById('game-screen');
    const inGame = gs && gs.classList.contains('active');
    starLayers.forEach(layer => {
        layer.stars.forEach(star => {
            let alpha = layer.alpha;
            if (inGame) {
                const dx = star.x - cx;
                const dy = star.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < gz) {
                    alpha = layer.alpha * (0.15 + dist / gz * 0.85);
                }
            }
            starsCtx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
            starsCtx.fillRect(Math.floor(star.x), Math.floor(star.y), layer.size, layer.size);
            star.y += layer.speed;
            if (star.y > starsCanvas.height + layer.size) {
                star.y = -layer.size * 2;
                star.x = Math.random() * starsCanvas.width;
            }
        });
    });
    requestAnimationFrame(animateStars);
}
resizeStars();
window.addEventListener('resize', resizeStars);
animateStars();

function drawIcon(id, type, active = true) {
    const canvas = document.getElementById(id);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const color = active ? getColor() : '#333';
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = color;
    if (type === 'stars') {
        ctx.fillRect(23,5,4,4); ctx.fillRect(19,9,12,4); ctx.fillRect(11,13,28,4);
        ctx.fillRect(15,17,20,4); ctx.fillRect(19,21,12,4); ctx.fillRect(15,25,8,4);
        ctx.fillRect(27,25,8,4); ctx.fillRect(11,29,8,4); ctx.fillRect(31,29,8,4);
    } else if (type === 'music') {
        ctx.fillRect(28,6,4,24); ctx.fillRect(32,6,10,3);
        ctx.fillRect(32,11,8,3); ctx.fillRect(14,24,18,12);
    } else if (type === 'home') {
        ctx.fillRect(23,5,4,6); ctx.fillRect(15,11,20,4); ctx.fillRect(11,15,28,4);
        ctx.fillRect(14,19,22,16); ctx.fillStyle = '#000'; ctx.fillRect(21,25,8,10);
    }
    const imageData = ctx.getImageData(0, 0, w, h);
    for (let y = 0; y < h; y++) {
        if (y % 2 === 1) {
            for (let x = 0; x < w; x++) {
                const i = (y * w + x) * 4;
                imageData.data[i + 3] = Math.floor(imageData.data[i + 3] * 0.3);
            }
        }
    }
    ctx.putImageData(imageData, 0, 0);
}
function drawAllIcons() {
    drawIcon('icon-stars', 'stars', starsOn);
    drawIcon('icon-music', 'music', !musicOff);
    drawIcon('icon-home', 'home', true);
}
function drawArrow(id, direction) {
    const canvas = document.getElementById(id);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawCenteredScanlineText(ctx, direction === 'left' ? '<' : '>', canvas.width, 8, 4, getColor());
}

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id + '-screen').classList.add('active');
    switch(id) {
        case 'menu': drawMenuScreen(); break;
        case 'difficulty': drawDifficultyScreen(); break;
        case 'game': drawGameScreen(); break;
        case 'howto': drawHowtoScreen(); break;
        case 'nickname': drawNicknameScreen(); break;
        case 'leaderboard': drawLeaderboardScreen(); break;
        case 'gameover': drawGameoverScreen(); break;
    }
    if (id !== 'nickname') stopNicknameInput();
}

function drawMenuScreen() {
    const color = getColor();
    const items = [
        ['menu-newgame', 'NEW GAME'],
        ['menu-leaderboard', 'LEADERBOARD'],
        ['menu-nickname', 'YOUR NICKNAME'],
        ['menu-howto', 'HOW TO PLAY'],
        ['menu-color', 'COLOR']
    ];
    items.forEach(([id, text]) => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCenteredScanlineText(ctx, text, canvas.width, 12, 3, color);
    });
}
function drawDifficultyScreen() {
    const color = getColor();
    const titleCanvas = document.getElementById('diff-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 300, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'SELECT MODE', 300, 10, 4, color);
    const buttons = [
        ['diff-training', 'TRAINING  4X4'],
        ['diff-challenge', 'CHALLENGE  5X5'],
        ['diff-expert', 'EXPERT  6X6'],
        ['diff-back', 'BACK']
    ];
    buttons.forEach(([id, text]) => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCenteredScanlineText(ctx, text, canvas.width, 12, 3, color);
    });
    drawChronoToggle('chrono-toggle', chronoOn);
}
function drawChronoToggle(canvasId, isOn) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    const color = getColor();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const ps = 3;
    const offW = getTextWidth('OFF', ps);
    const onW = getTextWidth('ON', ps);
    const boxPad = 4;
    const textH = 7 * ps;
    const chronoLabelW = getTextWidth('CHRONO', ps);
    const gap = 18;
    const totalW = chronoLabelW + gap + offW + boxPad * 2 + gap + onW + boxPad * 2;
    const startX = (canvas.width - totalW) / 2;
    const y = 12;
    drawScanlineText(ctx, 'CHRONO', startX, y, ps, color);
    const offBoxX = startX + chronoLabelW + gap;
    const onBoxX = offBoxX + offW + boxPad * 2 + gap;
    if (!isOn) {
        ctx.fillStyle = color;
        for (let py = 0; py < textH + boxPad * 2; py++) {
            if (py % 2 === 0) {
                ctx.fillRect(offBoxX - boxPad, y - boxPad + py, offW + boxPad * 2, 1);
            }
        }
        drawScanlineText(ctx, 'OFF', offBoxX, y, ps, '#000');
        drawScanlineText(ctx, 'ON', onBoxX, y, ps, color);
    } else {
        drawScanlineText(ctx, 'OFF', offBoxX, y, ps, color);
        ctx.fillStyle = color;
        for (let py = 0; py < textH + boxPad * 2; py++) {
            if (py % 2 === 0) {
                ctx.fillRect(onBoxX - boxPad, y - boxPad + py, onW + boxPad * 2, 1);
            }
        }
        drawScanlineText(ctx, 'ON', onBoxX, y, ps, '#000');
    }
}
function drawGameScreen() {
    drawAllIcons();
    drawPuzzle();
    const modeCanvas = document.getElementById('mode-canvas');
    const ctx = modeCanvas.getContext('2d');
    ctx.clearRect(0, 0, 400, 40);
    const modeNames = { 4: 'Training', 5: 'Challenge', 6: 'Expert' };
    const displayText = modeNames[gridSize] + '  ' + fmtScore(curScore) + ' PTS';
    drawCenteredScanlineText(ctx, displayText, 400, 10, 3, getColor());
    const timerCanvas = document.getElementById('timer-canvas');
    if (chronoOn) {
        timerCanvas.style.display = 'block';
        drawTimer();
    } else {
        timerCanvas.style.display = 'none';
    }
}
function drawTimer() {
    const canvas = document.getElementById('timer-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const minutes = Math.floor(chronoRem / 60);
    const seconds = chronoRem % 60;
    const timeText = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
    let color = getColor();
    if (chronoRem <= 10) color = '#f55';
    else if (chronoRem <= 30) color = '#fa5';
    drawCenteredScanlineText(ctx, timeText, canvas.width, 8, 4, color);
}
function drawHowtoScreen() {
    const color = getColor();
    const titleCanvas = document.getElementById('howto-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 280, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'HOW TO PLAY', 280, 10, 4, color);
    const contentCanvas = document.getElementById('howto-content');
    const ctx = contentCanvas.getContext('2d');
    ctx.clearRect(0, 0, 340, 320);
    const lines = [
        'TAP CIRCLES TO', 'FILL THEM', '',
        'EACH NUMBER SHOWS', 'HOW MANY NEIGHBORS', 'ARE FILLED', '',
        'MATCH ALL NUMBERS', 'TO WIN'
    ];
    lines.forEach((line, i) => {
        if (line) drawCenteredScanlineText(ctx, line, 340, 5 + i * 34, 3, color);
    });
    const backCanvas = document.getElementById('howto-back');
    backCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(backCanvas.getContext('2d'), 'BACK', 120, 10, 3, color);
}
function drawNicknameScreen() {
    const color = getColor();
    const titleCanvas = document.getElementById('nickname-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 320, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'YOUR NICKNAME', 320, 10, 4, color);
    drawNicknameInput();
    const saveCanvas = document.getElementById('nickname-save');
    saveCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(saveCanvas.getContext('2d'), 'SAVE', 120, 10, 3, color);
    const backCanvas = document.getElementById('nickname-back');
    backCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(backCanvas.getContext('2d'), 'BACK', 120, 10, 3, color);
}
function drawNicknameInput() {
    const canvas = document.getElementById('nickname-input-canvas');
    const ctx = canvas.getContext('2d');
    const color = getColor();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawCenteredScanlineText(ctx, nickIn || 'PLAYER', canvas.width, 15, 3, color);
    ctx.fillStyle = color;
    for (let x = 20; x < canvas.width - 20; x += 2) {
        ctx.fillRect(x, 45, 1, 2);
    }
}
function startNicknameInput() {
    nickAct = true;
    nickIn = nickname === 'PLAYER' ? '' : nickname;
    document.getElementById('hidden-input').value = nickIn;
    document.getElementById('hidden-input').focus();
    drawNicknameInput();
}
function stopNicknameInput() {
    nickAct = false;
    document.getElementById('hidden-input').blur();
}
function drawLeaderboardScreen() {
    const color = getColor();
    const titleCanvas = document.getElementById('leaderboard-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 300, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'LEADERBOARD', 300, 10, 4, color);
    drawChronoToggle('lb-chrono-title', curLbChrono === 1);
    drawArrow('lb-prev', 'left');
    drawArrow('lb-next', 'right');
    const modeTitles = ['TRAINING 4X4', 'CHALLENGE 5X5', 'EXPERT 6X6'];
    const modeCanvas = document.getElementById('lb-mode-title');
    modeCanvas.getContext('2d').clearRect(0, 0, 280, modeCanvas.height);
    drawCenteredScanlineText(modeCanvas.getContext('2d'), modeTitles[curLbMode], 280, 5, 3, color);
    const listCanvas = document.getElementById('leaderboard-list');
    const ctx = listCanvas.getContext('2d');
    ctx.clearRect(0, 0, 380, 350);
    drawCenteredScanlineText(ctx, 'LOADING...', 380, 160, 3, color);
    fetchLeaderboard().then(() => {
        ctx.clearRect(0, 0, 380, 350);
        const modeKey = lbModes[curLbMode] + (curLbChrono ? '_chrono' : '');
        const scores = lbData[modeKey] || [];
        if (scores.length === 0) {
            drawCenteredScanlineText(ctx, 'NO SCORES YET', 380, 160, 3, color);
        } else {
            scores.slice(0, 10).forEach((entry, i) => {
                const y = 10 + i * 34;
                drawScanlineText(ctx, (i + 1) + '.', 10, y, 3, color);
                drawScanlineText(ctx, entry.nickname, 55, y, 3, color);
                const scoreText = fmtScore(entry.score);
                const scoreWidth = getTextWidth(scoreText, 3);
                drawScanlineText(ctx, scoreText, 365 - scoreWidth, y, 3, color);
            });
        }
    });
    const backCanvas = document.getElementById('leaderboard-back');
    backCanvas.getContext('2d').clearRect(0, 0, 120, 40);
    drawCenteredScanlineText(backCanvas.getContext('2d'), 'BACK', 120, 10, 3, color);
}
function drawGameoverScreen() {
    const color = getColor();
    const titleCanvas = document.getElementById('gameover-title');
    titleCanvas.getContext('2d').clearRect(0, 0, 280, 50);
    drawCenteredScanlineText(titleCanvas.getContext('2d'), 'TIME UP', 280, 10, 4, color);
    const scoreCanvas = document.getElementById('gameover-score');
    const ctx = scoreCanvas.getContext('2d');
    ctx.clearRect(0, 0, 380, 120);
    drawCenteredScanlineText(ctx, fmtScore(curScore) + ' PTS', 380, 20, 4, color);
    drawCenteredScanlineText(ctx, solved + ' PUZZLES', 380, 70, 3, color);
    const restartCanvas = document.getElementById('gameover-restart');
    restartCanvas.getContext('2d').clearRect(0, 0, 200, 45);
    drawCenteredScanlineText(restartCanvas.getContext('2d'), 'RESTART', 200, 12, 3, color);
    const menuCanvas = document.getElementById('gameover-menu');
    menuCanvas.getContext('2d').clearRect(0, 0, 120, 45);
    drawCenteredScanlineText(menuCanvas.getContext('2d'), 'MENU', 120, 12, 3, color);
}

const LEADERBOARD_URL = 'https://script.google.com/macros/s/AKfycbzwwGm8kGbcjixpMpR3xhfH4gofyMPY1kXnPdcGzl4tnrJz7ewgVDH2J825Lhh93940/exec';
async function fetchLeaderboard() {
    try {
        const response = await fetch(LEADERBOARD_URL, { method: 'GET', redirect: 'follow' });
        const data = await response.json();
        lbData.training = (data.training || []).sort((a, b) => b.score - a.score);
        lbData.challenge = (data.challenge || []).sort((a, b) => b.score - a.score);
        lbData.expert = (data.expert || []).sort((a, b) => b.score - a.score);
        lbData.training_chrono = (data.training_chrono || []).sort((a, b) => b.score - a.score);
        lbData.challenge_chrono = (data.challenge_chrono || []).sort((a, b) => b.score - a.score);
        lbData.expert_chrono = (data.expert_chrono || []).sort((a, b) => b.score - a.score);
    } catch (e) {
        console.error('Leaderboard fetch error:', e);
    }
}
async function submitScore(score, mode) {
    if (score <= 0) return;
    try {
        const modeNames = { 4: 'training', 5: 'challenge', 6: 'expert' };
        const modeStr = modeNames[mode] || 'training';
        const finalMode = chronoOn ? modeStr + '_chrono' : modeStr;
        const params = new URLSearchParams({ nickname, score, mode: finalMode });
        const url = LEADERBOARD_URL + '?action=submit&' + params.toString();
        await fetch(url, { method: 'GET', redirect: 'follow' });
    } catch (e) {
        console.error('Score submit error:', e);
    }
}

function startChrono() {
    if (!chronoOn) return;
    chronoRem = chronoTime;
    chronoAct = true;
    chronoInt = setInterval(() => {
        chronoRem--;
        drawTimer();
        if (chronoRem <= 0) endChrono();
    }, 1000);
}
function stopChrono() {
    if (chronoInt) {
        clearInterval(chronoInt);
        chronoInt = null;
    }
    chronoAct = false;
}
function endChrono() {
    stopChrono();
    if (curScore > 0) submitScore(curScore, gridSize);
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicOn = false;
    document.getElementById('equalizer').classList.add('paused');
    showScreen('gameover');
}

function generatePuzzle() {
    circles = [];
    for (let y = 0; y < gridSize; y++) {
        circles[y] = [];
        for (let x = 0; x < gridSize; x++) {
            circles[y][x] = {
                filled: false,
                solution: Math.random() < 0.35
            };
        }
    }
    numbers = [];
    for (let y = 0; y < gridSize - 1; y++) {
        numbers[y] = [];
        for (let x = 0; x < gridSize - 1; x++) {
            let count = 0;
            if (circles[y][x].solution) count++;
            if (circles[y][x + 1].solution) count++;
            if (circles[y + 1][x].solution) count++;
            if (circles[y + 1][x + 1].solution) count++;
            numbers[y][x] = count;
        }
    }
}
function checkWin() {
    for (let y = 0; y < gridSize - 1; y++) {
        for (let x = 0; x < gridSize - 1; x++) {
            let count = 0;
            if (circles[y][x].filled) count++;
            if (circles[y][x + 1].filled) count++;
            if (circles[y + 1][x].filled) count++;
            if (circles[y + 1][x + 1].filled) count++;
            if (count !== numbers[y][x]) return false;
        }
    }
    return true;
}
function drawPuzzle() {
    const canvas = document.getElementById('puzzle-canvas');
    const ctx = canvas.getContext('2d');
    const color = getColor();
    const brightColor = getBrightColor();
    const maxSize = Math.min(500, window.innerWidth - 40, window.innerHeight - 250);
    const size = Math.max(280, maxSize);
    canvas.width = size;
    canvas.height = size;
    const cellSize = size / gridSize;
    const circleRadius = cellSize * 0.22;
    const lineWidth = Math.max(4, Math.floor(size / 100));
    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = color;
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cx = x * cellSize + cellSize / 2;
            const cy = y * cellSize + cellSize / 2;
            if (x < gridSize - 1) {
                const nextCx = (x + 1) * cellSize + cellSize / 2;
                for (let py = 0; py < lineWidth; py++) {
                    if (py % 2 === 0) {
                        ctx.fillRect(cx + circleRadius, cy - lineWidth/2 + py, nextCx - cx - circleRadius*2, 1);
                    }
                }
            }
            if (y < gridSize - 1) {
                const nextCy = (y + 1) * cellSize + cellSize / 2;
                for (let px = 0; px < lineWidth; px++) {
                    if (px % 2 === 0) {
                        ctx.fillRect(cx - lineWidth/2 + px, cy + circleRadius, 1, nextCy - cy - circleRadius*2);
                    }
                }
            }
        }
    }
    for (let y = 0; y < gridSize - 1; y++) {
        for (let x = 0; x < gridSize - 1; x++) {
            const cx = (x + 1) * cellSize;
            const cy = (y + 1) * cellSize;
            const num = numbers[y][x].toString();
            const textWidth = getTextWidth(num, 4);
            drawScanlineText(ctx, num, cx - textWidth/2, cy - 14, 4, brightColor);
        }
    }
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cx = x * cellSize + cellSize / 2;
            const cy = y * cellSize + cellSize / 2;
            const anim = anims.find(a => a.x === x && a.y === y);
            let animScale = 1;
            let animAlpha = 0;
            if (anim) {
                animScale = 1 + Math.sin(anim.progress * Math.PI) * 0.2;
                animAlpha = Math.sin(anim.progress * Math.PI) * 0.6;
            }
            const currentRadius = circleRadius * animScale;
            if (circles[y][x].filled) {
                ctx.fillStyle = color;
                for (let dy = -currentRadius; dy <= currentRadius; dy++) {
                    if (Math.floor(cy + dy) % 2 === 0) {
                        const width = Math.sqrt(currentRadius * currentRadius - dy * dy);
                        ctx.fillRect(cx - width, cy + dy, width * 2, 1);
                    }
                }
                if (animAlpha > 0) {
                    const rgb = hexToRgb(color);
                    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${animAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, currentRadius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else {
                ctx.fillStyle = color;
                const thickness = 4;
                for (let t = 0; t < thickness; t++) {
                    const r = currentRadius - t;
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.03) {
                        const px = cx + Math.cos(angle) * r;
                        const py = cy + Math.sin(angle) * r;
                        if (Math.floor(py) % 2 === 0) {
                            ctx.fillRect(Math.floor(px), Math.floor(py), 2, 1);
                        }
                    }
                }
            }
        }
    }
}
function triggerCircleAnimation(x, y) {
    anims = anims.filter(a => !(a.x === x && a.y === y));
    anims.push({ x, y, progress: 0 });
}
function updateAnimations() {
    if (anims.length > 0) {
        anims.forEach(a => a.progress += 0.08);
        anims = anims.filter(a => a.progress < 1);
        drawPuzzle();
    }
    requestAnimationFrame(updateAnimations);
}
updateAnimations();
function startGame(size) {
    gridSize = size;
    curScore = 0;
    solved = 0;
    generatePuzzle();
    showScreen('game');
    startMusicWithFade();
    if (chronoOn) startChrono();
}

const musicTracks = [
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music1.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music2.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music3.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music4.mp3',
    'https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/Music5.mp3'
];
let curTrack = 0;
let musicOn = false;
const bgMusic = new Audio(musicTracks[0]);
bgMusic.loop = false;
bgMusic.volume = 0.5;
bgMusic.addEventListener('ended', () => {
    curTrack = (curTrack + 1) % musicTracks.length;
    bgMusic.src = musicTracks[curTrack];
    bgMusic.play().catch(() => {});
});
const beepSound = new Audio('https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/beepMenuChoice.mp3');
beepSound.volume = 0.3;
let audCtx = null;
let beepBuffer = null;
async function initAudioContext() {
    if (audCtx) return;
    try {
        audCtx = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch('https://raw.githubusercontent.com/DNSZLSK/musubi/master/Music/beepMenuChoice.mp3');
        const arrayBuffer = await response.arrayBuffer();
        beepBuffer = await audCtx.decodeAudioData(arrayBuffer);
    } catch (e) {}
}
function playBeep() {
    if (audCtx && beepBuffer) {
        const source = audCtx.createBufferSource();
        const gain = audCtx.createGain();
        gain.gain.value = 0.3;
        source.buffer = beepBuffer;
        source.connect(gain);
        gain.connect(audCtx.destination);
        source.start(0);
    } else {
        beepSound.currentTime = 0;
        beepSound.play().catch(() => {});
    }
}
function startMusicWithFade() {
    if (musicOn) return;
    bgMusic.volume = 0;
    bgMusic.play().then(() => {
        musicOn = true;
        const eq = document.getElementById('equalizer');
        if (eq && !musicOff) eq.classList.remove('paused');
        let vol = 0;
        const fadeIn = setInterval(() => {
            vol += 0.02;
            if (vol >= 0.5) {
                vol = 0.5;
                clearInterval(fadeIn);
            }
            if (!musicOff) bgMusic.volume = vol;
        }, 80);
    }).catch(() => {});
}

document.addEventListener('click', () => initAudioContext(), { once: true });
document.addEventListener('click', (e) => {
    if (e.target.classList.contains('menu-item') ||
        e.target.classList.contains('top-icon') ||
        e.target.classList.contains('nav-arrow')) {
        playBeep();
    }
});
document.getElementById('menu-newgame').addEventListener('click', () => showScreen('difficulty'));
document.getElementById('menu-leaderboard').addEventListener('click', () => showScreen('leaderboard'));
document.getElementById('menu-nickname').addEventListener('click', () => showScreen('nickname'));
document.getElementById('menu-howto').addEventListener('click', () => showScreen('howto'));
document.getElementById('menu-color').addEventListener('click', () => {
    curTheme = (curTheme + 1) % themes.length;
    document.body.className = themes[curTheme];
    drawMenuScreen();
});
document.getElementById('diff-training').addEventListener('click', () => startGame(4));
document.getElementById('diff-challenge').addEventListener('click', () => startGame(5));
document.getElementById('diff-expert').addEventListener('click', () => startGame(6));
document.getElementById('diff-back').addEventListener('click', () => showScreen('menu'));
document.getElementById('chrono-toggle').addEventListener('click', () => {
    chronoOn = !chronoOn;
    drawDifficultyScreen();
    playBeep();
});
document.getElementById('icon-home').addEventListener('click', () => {
    stopChrono();
    if (curScore > 0) submitScore(curScore, gridSize);
    curScore = 0;
    solved = 0;
    bgMusic.pause();
    bgMusic.currentTime = 0;
    musicOn = false;
    document.getElementById('equalizer').classList.add('paused');
    showScreen('menu');
});
document.getElementById('icon-stars').addEventListener('click', () => {
    starsOn = !starsOn;
    drawIcon('icon-stars', 'stars', starsOn);
});
document.getElementById('icon-music').addEventListener('click', () => {
    musicOff = !musicOff;
    bgMusic.muted = musicOff;
    drawIcon('icon-music', 'music', !musicOff);
    const eq = document.getElementById('equalizer');
    musicOff ? eq.classList.add('paused') : eq.classList.remove('paused');
});
document.getElementById('equalizer').addEventListener('click', () => {
    curTrack = (curTrack + 1) % musicTracks.length;
    bgMusic.src = musicTracks[curTrack];
    bgMusic.play().catch(() => {});
});
document.getElementById('puzzle-canvas').addEventListener('click', (e) => {
    const canvas = document.getElementById('puzzle-canvas');
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    const cellSize = canvas.width / gridSize;
    const gridX = Math.floor(x / cellSize);
    const gridY = Math.floor(y / cellSize);
    if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
        circles[gridY][gridX].filled = !circles[gridY][gridX].filled;
        triggerCircleAnimation(gridX, gridY);
        drawPuzzle();
        if (checkWin()) {
            const points = gridSize * gridSize * 100;
            curScore += points;
            solved++;
            if (chronoOn && chronoAct) {
                const bonus = { 4: 10, 5: 15, 6: 20 };
                chronoRem += bonus[gridSize] || 10;
                drawTimer();
            }
            const modeCanvas = document.getElementById('mode-canvas');
            const ctx = modeCanvas.getContext('2d');
            ctx.clearRect(0, 0, 400, 40);
            const modeNames = { 4: 'Training', 5: 'Challenge', 6: 'Expert' };
            const displayText = modeNames[gridSize] + '  ' + fmtScore(curScore) + ' PTS';
            drawCenteredScanlineText(ctx, displayText, 400, 10, 3, getColor());
            setTimeout(() => {
                generatePuzzle();
                drawPuzzle();
            }, 500);
        }
    }
});
document.getElementById('howto-back').addEventListener('click', () => showScreen('menu'));
document.getElementById('nickname-input-canvas').addEventListener('click', () => startNicknameInput());
document.getElementById('hidden-input').addEventListener('input', function() {
    nickIn = this.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 10);
    this.value = nickIn;
    drawNicknameInput();
});
document.getElementById('hidden-input').addEventListener('blur', () => {
    if (nickAct) drawNicknameInput();
});
document.getElementById('nickname-save').addEventListener('click', () => {
    nickname = nickIn || 'PLAYER';
    localStorage.setItem('musubi_nickname', nickname);
    stopNicknameInput();
    showScreen('menu');
});
document.getElementById('nickname-back').addEventListener('click', () => {
    stopNicknameInput();
    showScreen('menu');
});
document.getElementById('lb-chrono-title').addEventListener('click', () => {
    curLbChrono = (curLbChrono + 1) % 2;
    drawLeaderboardScreen();
    playBeep();
});
document.getElementById('lb-prev').addEventListener('click', () => {
    curLbMode = (curLbMode - 1 + lbModes.length) % lbModes.length;
    drawLeaderboardScreen();
    playBeep();
});
document.getElementById('lb-next').addEventListener('click', () => {
    curLbMode = (curLbMode + 1) % lbModes.length;
    drawLeaderboardScreen();
    playBeep();
});
document.getElementById('leaderboard-back').addEventListener('click', () => showScreen('menu'));
document.getElementById('gameover-menu').addEventListener('click', () => {
    curScore = 0;
    solved = 0;
    showScreen('menu');
});
document.getElementById('gameover-restart').addEventListener('click', () => {
    curScore = 0;
    solved = 0;
    startGame(gridSize);
});

const preloader = document.getElementById('preloader');
const plCanvas = document.getElementById('preloader-canvas');
const plCtx = plCanvas.getContext('2d');
const gameCont = document.getElementById('game-container');
const assetsToLoad = 3;
let loadedCount = 0;
let plDone = false;
let plProg = 0;
let tProg = 0;
function drawPreloader() {
    const color = '#5c5';
    const w = plCanvas.width;
    const h = plCanvas.height;
    plCtx.clearRect(0, 0, w, h);
    drawCenteredScanlineText(plCtx, 'LOADING', w, 15, 4, color);
    drawCenteredScanlineText(plCtx, Math.floor(plProg) + '%', w, 55, 3, color);
    const bx = 30, by = 85, bw = w - 60, bh = 16;
    plCtx.fillStyle = color;
    for (let py = 0; py < 2; py++) if (py % 2 === 0) plCtx.fillRect(bx, by + py, bw, 1);
    for (let py = 0; py < 2; py++) if (py % 2 === 0) plCtx.fillRect(bx, by + bh - 2 + py, bw, 1);
    for (let px = 0; px < 2; px++) for (let py = 0; py < bh; py++) if (py % 2 === 0) plCtx.fillRect(bx + px, by + py, 1, 1);
    for (let px = 0; px < 2; px++) for (let py = 0; py < bh; py++) if (py % 2 === 0) plCtx.fillRect(bx + bw - 2 + px, by + py, 1, 1);
    const fillWidth = Math.floor((bw - 8) * (plProg / 100));
    if (fillWidth > 0) {
        for (let py = 0; py < bh - 8; py++) {
            if (py % 2 === 0) plCtx.fillRect(bx + 4, by + 4 + py, fillWidth, 1);
        }
    }
    if (plProg < tProg) {
        plProg += 2;
        if (plProg > tProg) plProg = tProg;
    }
    if (!plDone) requestAnimationFrame(drawPreloader);
}
function updateProgress() {
    if (plDone) return;
    loadedCount++;
    tProg = (loadedCount / assetsToLoad) * 100;
    if (loadedCount >= assetsToLoad) {
        tProg = 100;
        setTimeout(finishPreloader, 500);
    }
}
function finishPreloader() {
    if (plDone) return;
    plDone = true;
    preloader.style.transition = 'opacity 0.5s';
    preloader.style.opacity = '0';
    setTimeout(() => {
        preloader.style.display = 'none';
        gameCont.style.display = 'flex';
        drawMenuScreen();
    }, 500);
}
drawPreloader();
const logoImg = document.getElementById('logo-img');
if (logoImg.complete) {
    updateProgress();
} else {
    logoImg.onload = updateProgress;
    logoImg.onerror = updateProgress;
}
let musicLoaded = false;
function onMusicLoad() {
    if (!musicLoaded) {
        musicLoaded = true;
        updateProgress();
    }
}
bgMusic.oncanplaythrough = onMusicLoad;
bgMusic.onloadeddata = onMusicLoad;
bgMusic.onerror = onMusicLoad;
let beepLoaded = false;
function onBeepLoad() {
    if (!beepLoaded) {
        beepLoaded = true;
        updateProgress();
    }
}
beepSound.oncanplaythrough = onBeepLoad;
beepSound.onloadeddata = onBeepLoad;
beepSound.onerror = onBeepLoad;
setTimeout(() => {
    if (!plDone) {
        tProg = 100;
        setTimeout(finishPreloader, 300);
    }
}, 5000);
</script>
</body>
</html>